import os
import re
import logging
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
    ConversationHandler,
    CallbackQueryHandler
)
# рдЖрд╡рд╢реНрдпрдХ рдореЙрдбреНрдпреВрд▓ рд╣реА рд░рдЦреЗрдВ
from telegram.constants import ChatMemberStatus
from collections import defaultdict 
from telegram.error import BadRequest, Forbidden 
from typing import Tuple, Optional # Type Hinting рдХреЗ рд▓рд┐рдП

# .env рдлрд╝рд╛рдЗрд▓ рд╕реЗ environment variables рд▓реЛрдб рдХрд░реЗрдВ
load_dotenv()

# рд▓реЙрдЧрд┐рдВрдЧ рд╕реЗрдЯ рдХрд░реЗрдВ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# рдПрдирд╡рд╛рдпрд░реНрдирдореЗрдВрдЯ рд╡реЗрд░рд┐рдПрдмрд▓реНрд╕ рдХреЛ рд╕реБрд░рдХреНрд╖рд┐рдд рд░реВрдк рд╕реЗ рд▓реЗрдВ
BOT_TOKEN = os.getenv("BOT_TOKEN")
IMAGE_URL = os.getenv("IMAGE_URL", "https://picsum.photos/600/300") # Stylish Placeholder Image
LOG_CHANNEL_USERNAME = os.getenv("LOG_CHANNEL_USERNAME", "@teamrajweb") # Log Channel

# рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд╕реНрдЯреЗрдЯреНрд╕
(GET_CHANNEL_ID,) = range(1)

# рдбреЗрдЯрд╛рдмреЗрд╕ рдХреЗ рдмрд┐рдирд╛ рд╡реЛрдЯ рдЯреНрд░реИрдХ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рджреЛ рдЧреНрд▓реЛрдмрд▓ рдбрд┐рдХреНрд╢рдирд░реА (рдЕрд╕реНрдерд╛рдпреА!)
# рдмреЗрд╣рддрд░ рдкрд░рдлреЙрд░реНрдореЗрдВрд╕ рдХреЗ рд▓рд┐рдП рдЗрд╕реЗ рдбреЗрдЯрд╛рдмреЗрд╕ (рдЬреИрд╕реЗ Redis/SQL) рдореЗрдВ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред
VOTES_TRACKER = defaultdict(dict) # {user_id: {channel_id: True}}
VOTES_COUNT = defaultdict(int) # {channel_id: count}

# ----------------------------------------
# Utility / Parsing Helpers
# ----------------------------------------
def parse_poll_from_text(text: str) -> Optional[Tuple[str, list]]:
    """рдХрд┐рд╕реА raw text рдореЗрдВ рд╕реЗ poll parse рдХрд░реЗрдВред рд╕рд╡рд╛рд▓ рдФрд░ рдСрдкреНрд╢рди рдХреА рд╕реАрдорд╛ 2-10 рд░рдЦреА рдЧрдИ рд╣реИред"""
    if not text or '?' not in text:
        return None
    try:
        question_part, options_part = text.split('?', 1)
        question = question_part.strip()
        options_part = options_part.strip()
        # Regex рд╕реЗ split рдХрд░рдХреЗ рдмреЗрд╣рддрд░ рдЯреНрд░рд┐рдорд┐рдВрдЧ рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ
        options = [opt.strip() for opt in re.split(r',\s*', options_part) if opt.strip()]
        
        if not question or len(options) < 2 or len(options) > 10:
            return None
        return question, options
    except Exception:
        logging.exception("parse_poll_from_text failed")
        return None

# ----------------------------------------
# Core Bot Functions 
# ----------------------------------------
async def send_start_message(update: Update, context: ContextTypes.DEFAULT_TYPE, reply_markup: InlineKeyboardMarkup, welcome_message: str, chat_id: int | None = None):
    """рдЗрдореЗрдЬ рдпрд╛ рдЯреЗрдХреНрд╕реНрдЯ рдХреЗ рд╕рд╛рде рд╕реНрдЯрд╛рд░реНрдЯ рдореИрд╕реЗрдЬ рднреЗрдЬрддрд╛ рд╣реИред"""
    target_chat_id = chat_id if chat_id else update.effective_chat.id
    try:
        # рдЗрдореЗрдЬ рдХреЗ рд╕рд╛рде рдЖрдХрд░реНрд╖рдХ рд╡реЗрд▓рдХрдо рдореИрд╕реЗрдЬ
        await context.bot.send_photo(
            chat_id=target_chat_id,
            photo=IMAGE_URL,
            caption=welcome_message,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
    except Exception as e:
        logging.error(f"Image send failed: {e}. Sending text message instead.")
        try:
            # рдЕрдЧрд░ рдЗрдореЗрдЬ рднреЗрдЬрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ рд╣реЛ, рддреЛ рдлреЙрд▓рдмреИрдХ рдЯреЗрдХреНрд╕реНрдЯ рдореИрд╕реЗрдЬ
            await context.bot.send_message(
                chat_id=target_chat_id,
                text=welcome_message,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
        except Exception:
            logging.exception("Failed to send fallback welcome message")


# 1. /start рдХрдорд╛рдВрдб (Deep Link Handling рдХреЗ рд╕рд╛рде)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    bot_user = await context.bot.get_me()
    bot_username = bot_user.username
    
    # --- DEEP LINK LOGIC (Channel Join Tracker) ---
    if context.args:
        payload = context.args[0]
        match = re.match(r'link_(\d+)', payload)

        if match:
            channel_id_str = match.groups()[0]
            # Telegram Channel IDs are typically -100XXXXXXXXXX
            target_channel_id_numeric = int(f"-100{channel_id_str}") 
            
            # рд╡рд░реНрддрдорд╛рди рд╡реЛрдЯ рдХреА рд╕рдВрдЦреНрдпрд╛ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
            current_vote_count = VOTES_COUNT[target_channel_id_numeric]

            try:
                chat_info = await context.bot.get_chat(chat_id=target_channel_id_numeric)
                channel_title = chat_info.title
                channel_url = chat_info.invite_link or f"https://t.me/{chat_info.username}" if chat_info.username else None
                
                # A. User рдХреЛ рдХрдиреНрдлрд░реНрдореЗрд╢рди рдореИрд╕реЗрдЬ рднреЗрдЬреЗрдВ
                await update.message.reply_text(
                    f"тЬи **You've Successfully Connected!** ЁЯОЙ\n\n"
                    f"рдЖрдк рдЪреИрдирд▓ **`{channel_title}`** рд╕реЗ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЬреБрдбрд╝ рдЧрдП рд╣реИрдВред\n"
                    f"рдпрд╣ рд▓рд┐рдВрдХ рдЕрдм рд╕рдХреНрд░рд┐рдп (Active) рд╣реИред рдЖрдк рдЕрдм рд╡реЛрдЯ рджреЗ рд╕рдХрддреЗ рд╣реИрдВ, рдЕрдЧрд░ рдХрд┐рд╕реА рдкреЛрд╕реНрдЯ рдкрд░ рд╡реЛрдЯрд┐рдВрдЧ рд╕рдХреНрд░рд┐рдп рд╣реИред"
                )

                # B. Notification message рдЪреИрдирд▓ рдореЗрдВ рднреЗрдЬреЗрдВ (Advanced Style)
                
                notification_message = (
                    f"**ЁЯСС New Participant Joined! ЁЯСС**\n"
                    f"--- **Participation Details** ---\n\n"
                    f"ЁЯСд **Name:** [{user.first_name}](tg://user?id={user.id})\n"
                    f"ЁЯЖФ **User ID:** `{user.id}`\n"
                    f"ЁЯМР **Username:** {f'@{user.username}' if user.username else 'N/A'}\n\n"
                    f"ЁЯФЧ **Channel:** `{channel_title}`\n"
                    f"ЁЯдЦ **Bot:** @{bot_username}"
                )

                # --- ADVANCED VOTE BUTTON LOGIC ---
                vote_callback_data = f'vote_{target_channel_id_numeric}'
                vote_button_text = f"тЬЕ Vote Now ({current_vote_count} Votes)"

                channel_keyboard = []
                # 1. Vote Button (рд╡реЛрдЯ рдХрд╛рдЙрдВрдЯ рдХреЗ рд╕рд╛рде)
                channel_keyboard.append([
                    InlineKeyboardButton(vote_button_text, callback_data=vote_callback_data)
                ])
                
                # 2. Go to Channel button
                if channel_url:
                    channel_keyboard.append([
                        InlineKeyboardButton("тЮбя╕П Go to Channel", url=channel_url)
                    ])

                channel_markup = InlineKeyboardMarkup(channel_keyboard)

                # Image рдХреЗ рд╕рд╛рде рдПрдбрд╡рд╛рдВрд╕ рдореИрд╕реЗрдЬ рднреЗрдЬреЗрдВ (Optional: Log Channel рдореЗрдВ рднреА рднреЗрдЬ рд╕рдХрддреЗ рд╣реИрдВ)
                try:
                    await context.bot.send_photo(
                        chat_id=target_channel_id_numeric,
                        photo=IMAGE_URL,
                        caption=notification_message,
                        parse_mode='Markdown',
                        reply_markup=channel_markup
                    )
                except (Forbidden, BadRequest) as fb_e:
                     # рдпрджрд┐ рдмреЙрдЯ рдЪреИрдирд▓ рдореЗрдВ рдкреЛрд╕реНрдЯ рдирд╣реАрдВ рдХрд░ рд╕рдХрддрд╛
                    logging.warning(f"Failed to send notification to channel {target_channel_id_numeric}: {fb_e}")

                return

            except Exception as e:
                logging.error(f"Deep link notification failed: {e}")
                await update.message.reply_text("рдорд╛рдлрд╝ рдХрд░рдирд╛, рдЪреИрдирд▓ рд╕реЗ рдЬреБрдбрд╝рдиреЗ/рд╕реВрдЪрдирд╛ рднреЗрдЬрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ рд╣реБрдИред рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдмреЙрдЯ рдЪреИрдирд▓ рдХрд╛ рдПрдбрдорд┐рди рд╣реИ рдФрд░ рд╕рд╣реА рдЕрдиреБрдорддрд┐рдпрд╛рдБ (permissions) рдкреНрд░рд╛рдкреНрдд рд╣реИрдВред")
    
    # --- REGULAR START MENU (Stylish Buttons) ---
    keyboard = [
        [
            InlineKeyboardButton("ЁЯФЧ рдЕрдкрдиреА рд▓рд┐рдВрдХ рдмрдирд╛рдПрдБ", callback_data='start_channel_conv'),
            InlineKeyboardButton("тЮХ рдЧреНрд░реБрдк рдореЗрдВ рдЬреЛрдбрд╝реЗрдВ", url=f"https://t.me/{bot_username}?startgroup=true")
        ],
        [
            InlineKeyboardButton("ЁЯУК рдореЗрд░реЗ рд╡реЛрдЯреНрд╕", callback_data='my_polls_list'),
            InlineKeyboardButton("тЭУ рдЧрд╛рдЗрдб", url='https://t.me/teamrajweb'),
            InlineKeyboardButton("ЁЯУв рдЪреИрдирд▓", url='https://t.me/narzoxbot')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    welcome_message = (
        "**ЁЯСС рд╡реЛрдЯ рдмреЙрдЯ рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ! ЁЯСС**\n\n"
        "рдЪреИрдирд▓ рдХреЛ рдХрдиреЗрдХреНрдЯ рдХрд░ **рддреБрд░рдВрдд рд╢реЗрдпрд░ рд▓рд┐рдВрдХ** рдкрд╛рдиреЗ рд╣реЗрддреБ *'ЁЯФЧ рдЕрдкрдиреА рд▓рд┐рдВрдХ рдмрдирд╛рдПрдБ'* рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред\n\n"
        "__**Stylish Quote:**__\n"
        "*\"рдЖрдкрдХреЗ рд╡рд┐рдЪрд╛рд░ рдорд╛рдпрдиреЗ рд░рдЦрддреЗ рд╣реИрдВред рд╡реЛрдЯ рджреЗрдВ, рдмрджрд▓рд╛рд╡ рд▓рд╛рдПрдБред\"*\n"
        "~ The Voting Bot"
    )

    await send_start_message(update, context, reply_markup, welcome_message)


# 2. рд╕рд╛рдзрд╛рд░рдг /poll рдХрдорд╛рдВрдб (chat рдореЗрдВ)
async def create_poll(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """рдПрдХ рд╕рд╛рдзрд╛рд░рдг Telegram poll рдмрдирд╛рддрд╛ рд╣реИ (Voting Bot рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рдирд╣реАрдВ, рд▓реЗрдХрд┐рди рдЙрдкрдпреЛрдЧреА)ред"""
    parsed = parse_poll_from_text(" ".join(context.args))

    if not parsed:
        await update.message.reply_text(
            "рдХреГрдкрдпрд╛ рд╕рд╣реА рдлреЙрд░реНрдореЗрдЯ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВ:\n"
            "`/poll [рд╕рд╡рд╛рд▓]? [рдСрдкреНрд╢рди1], [рдСрдкреНрд╢рди2], ...`\n"
            "рдХрдо рд╕реЗ рдХрдо 2 рдФрд░ рдЕрдзрд┐рдХрддрдо 10 рдСрдкреНрд╢рди рджреЗрдВред",
            parse_mode='Markdown'
        )
        return

    question, options = parsed
    try:
        await context.bot.send_poll(
            chat_id=update.effective_chat.id,
            question=question,
            options=options,
            is_anonymous=False, # рдЗрд╕реЗ anonymous рдирд╣реАрдВ рд░рдЦрддреЗ рд╣реИрдВ
            allows_multiple_answers=False,
        )
        await update.message.reply_text("тЬЕ рдЖрдкрдХрд╛ рд╡реЛрдЯ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдмрдирд╛ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ!")
    except Exception as e:
        logging.exception("Failed to send poll in chat")
        await update.message.reply_text(f"рд╡реЛрдЯ рднреЗрдЬрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ рд╣реБрдИ: {e}")


# 3. Callback рд╕реЗ рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд╢реБрд░реВ рдХрд░рдирд╛
async def start_channel_poll_conversation_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="ЁЯСЛ **рдЪреИрдирд▓ рд▓рд┐рдВрдХ рд╕реЗрдЯрдЕрдк:**\n"
             "рдХреГрдкрдпрд╛ рдЙрд╕ **рдЪреИрдирд▓ рдХрд╛ @username рдпрд╛ ID** (`-100...`) рднреЗрдЬреЗрдВ рдЬрд┐рд╕рдХреЗ рд▓рд┐рдП рдЖрдк рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред\n\n"
             "**рдиреЛрдЯ:** рдореБрдЭреЗ рдЗрд╕ рдЪреИрдирд▓ рдХрд╛ **рдПрдбрдорд┐рди** рд╣реЛрдирд╛ рдЬрд╝рд░реВрд░реА рд╣реИред",
        parse_mode='Markdown'
    )
    return GET_CHANNEL_ID


# 4. рдЪреИрдирд▓ ID рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ, рдмреЙрдЯ рдПрдбрдорд┐рди рдЪреЗрдХ рдХрд░реЗрдВ рдФрд░ INSTANT LINK рднреЗрдЬреЗрдВ
async def get_channel_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    channel_id_input = update.message.text.strip()
    user = update.effective_user

    # ID detection and normalization logic
    if re.match(r'^-?\d+$', channel_id_input):
        channel_id = int(channel_id_input)
    else:
        channel_id = channel_id_input if channel_id_input.startswith('@') else f"@{channel_id_input}"

    try:
        bot_user = await context.bot.get_me()
        bot_id = bot_user.id
        bot_username = bot_user.username or "bot"

        # 1. рдмреЙрдЯ рдПрдбрдорд┐рди рдЪреЗрдХ рдХрд░реЗрдВ рдФрд░ рдЪреИрдЯ рдХреА рдЬрд╛рдирдХрд╛рд░реА рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
        chat_member = await context.bot.get_chat_member(chat_id=channel_id, user_id=bot_id)
        chat_info = await context.bot.get_chat(chat_id=channel_id)
        
        if getattr(chat_member, "status", "").lower() in ['administrator', 'creator']:
            
            # 2. рд╕рдлрд▓рддрд╛: INSTANT UNIQUE LINK рдмрдирд╛рдПрдВ
            raw_id_str = str(chat_info.id)
            link_channel_id = raw_id_str[4:] if raw_id_str.startswith('-100') else raw_id_str.replace('-', '')

            deep_link_payload = f"link_{link_channel_id}"
            share_url = f"https://t.me/{bot_username}?start={deep_link_payload}"
            channel_title = chat_info.title
            
            # 3. рдпреВрдЬрд╝рд░ рдХреЛ рд▓рд┐рдВрдХ рджрд┐рдЦрд╛рдПрдБ (рдХреЙрдкреА рдХрд░рдиреЗ рдпреЛрдЧреНрдп)
            await update.message.reply_text(
                f"тЬЕ рдЪреИрдирд▓ **{channel_title}** рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдХрдиреЗрдХреНрдЯ рд╣реЛ рдЧрдпрд╛ рд╣реИ!\n\n"
                f"**рдЖрдкрдХреА рд╢реЗрдпрд░ рдХрд░рдиреЗ рдпреЛрдЧреНрдп UNIQUE LINK рддреИрдпрд╛рд░ рд╣реИред рдЗрд╕реЗ рдХреЙрдкреА рдХрд░реЗрдВ:**\n"
                f"```\n{share_url}\n```\n\n"
                f"**рдпрд╛ рдЗрд╕ рдмрдЯрди рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВ:**",
                parse_mode='Markdown'
            )
            
            # 4. рдмрдЯрди рднреЗрдЬреЗрдВ
            share_keyboard = [[
                InlineKeyboardButton("ЁЯФЧ рдЕрдкрдиреА рд▓рд┐рдВрдХ рд╢реЗрдпрд░ рдХрд░реЗрдВ", url=share_url),
            ]]
            share_markup = InlineKeyboardMarkup(share_keyboard)
            
            await update.message.reply_text(
                "рд╢реЗрдпрд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдмрдЯрди рджрдмрд╛рдПрдБ:",
                reply_markup=share_markup
            )
            
            # 5. LOG_CHANNEL_USERNAME рдореЗрдВ рд╕реВрдЪрдирд╛ рднреЗрдЬреЗрдВ
            if LOG_CHANNEL_USERNAME:
                log_message = (
                    f"**ЁЯФЧ рдирдпрд╛ рдЪреИрдирд▓ рд▓рд┐рдВрдХ рдмрдирд╛!**\n"
                    f"рдпреВрдЬрд░: [{user.first_name}](tg://user?id={user.id})\n"
                    f"рдЪреИрдирд▓: `{channel_title}`\n"
                    f"рд╢реЗрдпрд░ рд▓рд┐рдВрдХ: {share_url}"
                )
                await context.bot.send_message(
                    chat_id=LOG_CHANNEL_USERNAME,
                    text=log_message,
                    parse_mode='Markdown'
                )

            return ConversationHandler.END # рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд╕рдорд╛рдкреНрдд

        else:
            # 3. рдЕрд╕рдлрд▓рддрд╛: рдмреЙрдЯ рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИ
            await update.message.reply_text(
                "тЭМ рдореИрдВ рдЖрдкрдХреЗ рдЪреИрдирд▓ рдХрд╛ **рдПрдбрдорд┐рди рдирд╣реАрдВ** рд╣реВрдБред\n"
                "рдХреГрдкрдпрд╛ рдореБрдЭреЗ рдПрдбрдорд┐рди (рдХрдо рд╕реЗ рдХрдо **'Post Messages'** рдХреА рдЕрдиреБрдорддрд┐ рдХреЗ рд╕рд╛рде) рдмрдирд╛рдПрдБ рдФрд░ рдлрд┐рд░ рд╕реЗ рдЪреИрдирд▓ рдХрд╛ @username/ID рднреЗрдЬреЗрдВред"
            )
            return GET_CHANNEL_ID # рдЗрд╕реА рд╕реНрдЯреЗрдЯ рдореЗрдВ рд░рд╣реЗрдВ

    except Exception as e:
        logging.error(f"Error in get_channel_id for input {channel_id_input}: {e}")
        await update.message.reply_text(
            "тЪая╕П **рдЪреИрдирд▓ рддрдХ рдкрд╣реБрдБрдЪрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐** рд╣реБрдИред рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐:\n"
            "1. рдЪреИрдирд▓ рдХрд╛ @username/ID рд╕рд╣реА рд╣реИред\n"
            "2. рдЪреИрдирд▓ **рдкрдмреНрд▓рд┐рдХ** рд╣реИ рдпрд╛ рдЖрдкрдиреЗ рдореБрдЭреЗ рдЪреИрдирд▓ рдореЗрдВ **рдПрдбрдорд┐рди** рдХреЗ рд░реВрдк рдореЗрдВ рдЬреЛрдбрд╝рд╛ рд╣реИред"
        )
        return GET_CHANNEL_ID


# 5. cancel handler
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд░рджреНрдж рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред')
    return ConversationHandler.END


# ----------------------------------------
# Vote Handler (Fixing Subscription Check Error)
# ----------------------------------------
async def handle_vote(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    
    # 1. Callback data рд╕реЗ Channel ID рдирд┐рдХрд╛рд▓реЗрдВ
    data = query.data
    match = re.match(r'vote_(-?\d+)', data)
    
    if not match:
        await query.answer(text="тЭМ рддреНрд░реБрдЯрд┐: рд╡реЛрдЯ ID рд╕рд╣реА рдирд╣реАрдВ рд╣реИред", show_alert=True)
        return

    channel_id_numeric = int(match.group(1))
    user_id = query.from_user.id
    
    # 2. One-Time Vote Logic Check
    has_voted = VOTES_TRACKER[user_id].get(channel_id_numeric, False)
    
    if has_voted:
        await query.answer(text="ЁЯЧ│я╕П рдЖрдк рдкрд╣рд▓реЗ рд╣реА рдЗрд╕ рдкреЛрд╕реНрдЯ рдкрд░ рд╡реЛрдЯ рдХрд░ рдЪреБрдХреЗ рд╣реИрдВред", show_alert=True)
        return
        
    # 3. рдпреВрдЬрд╝рд░ рдХрд╛ рд╕рдмреНрд╕рдХреНрд░рд┐рдкреНрд╢рди рд╕реНрдЯреЗрдЯрд╕ рдЪреЗрдХ рдХрд░реЗрдВ (рд╕рдмрд╕реЗ рдорд╣рддреНрд╡рдкреВрд░реНрдг рд╕реБрдзрд╛рд░)
    is_subscriber = False
    channel_url = None
    
    try:
        # рдЪреИрдирд▓ рдХреА рдЬрд╛рдирдХрд╛рд░реА рдкрд╣рд▓реЗ рд╣реА рдкреНрд░рд╛рдкреНрдд рдХрд░ рд▓реЗрдВ (URL рдХреЗ рд▓рд┐рдП)
        chat_info = await context.bot.get_chat(chat_id=channel_id_numeric)
        channel_url = chat_info.invite_link or f"https://t.me/{chat_info.username}" if chat_info.username else None
        
        # рдмреЙрдЯ рд╕рджрд╕реНрдп рдХреА рд╕реНрдерд┐рддрд┐ рдХреА рдЬрд╛рдБрдЪ рдХрд░рдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░рддрд╛ рд╣реИ
        chat_member = await context.bot.get_chat_member(chat_id=channel_id_numeric, user_id=user_id)
        is_subscriber = chat_member.status in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.CREATOR]
        
    except (Forbidden, BadRequest) as e:
        # рдпрд╣ рддреНрд░реБрдЯрд┐ рддрдм рдЖрддреА рд╣реИ рдЬрдм рдмреЙрдЯ рдПрдбрдорд┐рди рддреЛ рд╣реИ, рд▓реЗрдХрд┐рди рдЙрд╕рдХреЗ рдкрд╛рд╕ 'Manage Users' рдХреА рдЕрдиреБрдорддрд┐ рдирд╣реАрдВ рд╣реИред
        logging.error(f"Bot failed to check subscriber status for {channel_id_numeric}: {e}")
        
        # рдПрдбрдорд┐рди рдХреЗ рд▓рд┐рдП рд╕реНрдкрд╖реНрдЯ рдЕрд▓рд░реНрдЯ
        await query.answer(
            text="ЁЯЪи рд╡реЛрдЯрд┐рдВрдЧ рддреНрд░реБрдЯрд┐: рдмреЙрдЯ рдЪреИрдирд▓ рд╕рджрд╕реНрдпрддрд╛ рдЬрд╛рдБрдЪрдиреЗ рдореЗрдВ рдЕрд╕рдорд░реНрде рд╣реИред рдХреГрдкрдпрд╛ рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдмреЙрдЯ рдХреЗ рдкрд╛рд╕ **'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛рдУрдВ рдХреЛ рдкреНрд░рдмрдВрдзрд┐рдд рдХрд░реЗрдВ' (Manage Users)** рдХреА рдЕрдиреБрдорддрд┐ рд╣реИред",
            show_alert=True
        )
        return
    except Exception as e:
        # Catch any other unexpected error
        logging.exception(f"Unknown error in handle_vote for {channel_id_numeric}")
        await query.answer(
            text="тЪая╕П рдЕрдкреНрд░рддреНрдпрд╛рд╢рд┐рдд рддреНрд░реБрдЯрд┐ рд╣реБрдИред рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ рдЪреИрдирд▓ рдПрдбрдорд┐рди рд╕реЗ рд╕рдВрдкрд░реНрдХ рдХрд░реЗрдВред",
            show_alert=True
        )
        return

    # 4. рд╡реЛрдЯрд┐рдВрдЧ рд▓реЙрдЬрд┐рдХ (рдЕрдЧрд░ рд╕рджрд╕реНрдпрддрд╛ рдЬрд╛рдБрдЪ рд╕рдлрд▓ рд░рд╣реА)
    
    if not is_subscriber:
        # рдЕрдЧрд░ рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдмрд░ рдирд╣реАрдВ рд╣реИ
        await query.answer(
            text="тЭМ рдЖрдк рд╡реЛрдЯ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред рдХреГрдкрдпрд╛ рдкрд╣рд▓реЗ рдЪреИрдирд▓ рдХреЛ рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдм рдХрд░реЗрдВред", 
            show_alert=True,
            url=channel_url if channel_url else None # рдЕрдЧрд░ URL рд╣реИ рддреЛ рдХреНрд▓рд┐рдХреЗрдмрд▓ рдмрдЯрди рджрд┐рдЦрд╛рдПрдЧрд╛
        )
        return
    
    else:
        # рд╕рдлрд▓ рд╡реЛрдЯ
        
        VOTES_TRACKER[user_id][channel_id_numeric] = True
        VOTES_COUNT[channel_id_numeric] += 1
        current_vote_count = VOTES_COUNT[channel_id_numeric]
        
        await query.answer(text=f"тЬЕ рдЖрдкрдХрд╛ рд╡реЛрдЯ ({current_vote_count}рд╡рд╛рдВ) рджрд░реНрдЬ рдХрд░ рд▓рд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдзрдиреНрдпрд╡рд╛рдж!", show_alert=True)
        
        # 5. рдмрдЯрди рдХреЛ рдирдП рд╡реЛрдЯ рдХрд╛рдЙрдВрдЯ рдХреЗ рд╕рд╛рде рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ
        original_markup = query.message.reply_markup
        new_keyboard = []
        
        if original_markup and original_markup.inline_keyboard:
            for row in original_markup.inline_keyboard:
                new_row = []
                for button in row:
                    if button.callback_data and button.callback_data.startswith('vote_'):
                        new_button_text = f"тЬЕ Vote Now ({current_vote_count} Votes)"
                        new_row.append(InlineKeyboardButton(new_button_text, callback_data=button.callback_data))
                    else:
                        new_row.append(button)
                new_keyboard.append(new_row)
        
        new_markup = InlineKeyboardMarkup(new_keyboard)
        
        try:
            await query.edit_message_reply_markup(reply_markup=new_markup)
        except Exception as e:
             # рдЗрд╕реЗ warning рдХреЗ рдмрдЬрд╛рдп debug рдпрд╛ info рдкрд░ рд░рдЦреЗрдВ, рдХреНрдпреЛрдВрдХрд┐ рдпрд╣ рдЕрдХреНрд╕рд░ рд╣реЛрддрд╛ рд╣реИ
             logging.info(f"Could not edit vote message markup: {e}")
            
# ----------------------------------------
# main() - Application Setup
# ----------------------------------------
def main():
    """рдмреЙрдЯ рдПрдкреНрд▓реАрдХреЗрд╢рди рд╢реБрд░реВ рдХрд░рддрд╛ рд╣реИ рдФрд░ рд╕рднреА рд╣реИрдВрдбрд▓реНрд╕ рдЬреЛрдбрд╝рддрд╛ рд╣реИред"""
    if not BOT_TOKEN:
        logging.error("BOT_TOKEN environment variable рд╕реЗрдЯ рдирд╣реАрдВ рд╣реИред рдХреГрдкрдпрд╛ .env рдлрд╝рд╛рдЗрд▓ рдореЗрдВ TOKEN рдЬреЛрдбрд╝реЗрдВред")
        return

    application = ApplicationBuilder().token(BOT_TOKEN).build() 

    # 1. /start (Deep Link Logic Included)
    application.add_handler(CommandHandler("start", start))

    # 2. simple /poll for chats (Optional feature)
    application.add_handler(CommandHandler("poll", create_poll))

    # 3. Vote Callback Handler 
    application.add_handler(CallbackQueryHandler(handle_vote, pattern=r'^vote_(-?\d+)$')) 

    # 4. Conversation for instant link generation
    link_conv_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(start_channel_poll_conversation_cb, pattern='^start_channel_conv$'),
        ],
        states={
            GET_CHANNEL_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_channel_id)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
        allow_reentry=False
    )

    application.add_handler(link_conv_handler)

    logging.info("ЁЯСС Stylish Voting Bot Starting... ЁЯЪА")
    application.run_polling(poll_interval=2) 


if __name__ == '__main__':
    main()
